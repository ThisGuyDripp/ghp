let scene, camera, renderer, controls, planeMesh;

// Scene Initialization
function initThreeScene() {
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth * 0.8, window.innerHeight * 0.6);
  document.getElementById('3d-viewer').appendChild(renderer.domElement);

  // Lighting
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
  scene.add(ambientLight);
  
  const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
  directionalLight.position.set(5, 5, 5);
  scene.add(directionalLight);

  // Controls
  controls = new THREE.OrbitControls(camera, renderer.domElement);
  camera.position.z = 8;

  // Initial Lattice
  createCubicLattice();
}

// Lattice Generation
function createCubicLattice(size = 2) {
  scene.clear();
  
  // Atoms
  const atomGeometry = new THREE.SphereGeometry(0.2, 32, 32);
  const atomMaterial = new THREE.MeshPhongMaterial({ 
    color: 0x3a7ca5,
    metalness: 0.8,
    roughness: 0.3
  });

  for(let x = 0; x <= size; x += size) {
    for(let y = 0; y <= size; y += size) {
      for(let z = 0; z <= size; z += size) {
        const atom = new THREE.Mesh(atomGeometry, atomMaterial);
        atom.position.set(x, y, z);
        scene.add(atom);
      }
    }
  }

  // Bonds
  const bondGeometry = new THREE.CylinderGeometry(0.05, 0.05, size);
  const bondMaterial = new THREE.MeshPhongMaterial({ color: 0x2f5233 });

  [[0,1], [0,2], [1,3], [2,3], [4,5], [4,6], [5,7], [6,7]].forEach(([i, j]) => {
    const bond = new THREE.Mesh(bondGeometry, bondMaterial);
    const start = scene.children[i].position;
    const end = scene.children[j].position;
    bond.position.copy(start).lerp(end, 0.5);
    bond.quaternion.setFromUnitVectors(
      new THREE.Vector3(0,1,0),
      new THREE.Vector3().subVectors(end, start).normalize()
    );
    scene.add(bond);
  });
}

// Miller Plane Visualization
function update3DPlane(h, k, l) {
  if(planeMesh) scene.remove(planeMesh);
  
  const planeGeometry = new THREE.PlaneGeometry(4, 4);
  const planeMaterial = new THREE.MeshPhongMaterial({
    color: 0xff0000,
    opacity: 0.3,
    transparent: true,
    side: THREE.DoubleSide
  });

  planeMesh = new THREE.Mesh(planeGeometry, planeMaterial);
  planeMesh.rotation.set(
    Math.atan(k / h),
    Math.atan(l / h),
    0
  );
  scene.add(planeMesh);
}

// Event Listeners
document.getElementById('resetCamera').addEventListener('click', () => {
  controls.reset();
  camera.position.z = 8;
});

document.getElementById('toggleAxes').addEventListener('click', () => {
  scene.children.forEach(child => {
    if(child.type === 'AxesHelper') child.visible = !child.visible;
  });
});

document.getElementById('fullscreen').addEventListener('click', () => {
  if(!document.fullscreenElement) {
    renderer.domElement.requestFullscreen();
  } else {
    document.exitFullscreen();
  }
});

// Initialize
initThreeScene();
animate();

function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}

// Responsive Handling
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth * 0.8, window.innerHeight * 0.6);
});
