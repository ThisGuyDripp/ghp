import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

// Scene Management
export function initializeThreeScene() {
  scene = new THREE.Scene();
  initRenderer();
  initCameraAndControls();
  initLighting();
  createCrystalLattice();
  animate();
}

function initRenderer() {
  renderer = new THREE.WebGLRenderer({ 
    antialias: true,
    alpha: true,
    powerPreference: 'high-performance'
  });
  renderer.setSize(window.innerWidth * 0.8, window.innerHeight * 0.6);
  document.getElementById('3d-viewer').appendChild(renderer.domElement);
}

function initCameraAndControls() {
  camera = new THREE.PerspectiveCamera(75, 
    window.innerWidth / window.innerHeight, 0.1, 1000
  );
  camera.position.z = 8;
  controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.05;
}

function initLighting() {
  scene.add(new THREE.AmbientLight(0xffffff, 0.5));
  const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
  directionalLight.position.set(5, 5, 5);
  scene.add(directionalLight);
}

// Crystal Lattice Generation
export function createCrystalLattice(mineral = null) {
  clearScene();
  showViewerLoading(true);

  try {
    const params = mineral?.lattice || { a: 2 };
    switch(mineral?.system?.toLowerCase()) {
      case 'hexagonal':
        createHexagonalLattice(params);
        break;
      case 'trigonal':
        createTrigonalLattice(params);
        break;
      default:
        createCubicLattice(params);
    }
  } catch (error) {
    console.error('Lattice creation error:', error);
    showError('3D visualization failed');
  } finally {
    showViewerLoading(false);
  }
}

function createCubicLattice({ a = 2 } = {}) {
  const atomMaterial = createDynamicMaterial('crystal');
  const bondMaterial = createDynamicMaterial('bond');
  
  // Atoms
  for(let x = 0; x <= a; x += a) {
    for(let y = 0; y <= a; y += a) {
      for(let z = 0; z <= a; z += a) {
        const atom = new THREE.Mesh(
          new THREE.SphereGeometry(0.2),
          atomMaterial
        );
        atom.position.set(x, y, z);
        scene.add(atom);
      }
    }
  }

  // Bonds
  const bondGeometry = new THREE.CylinderGeometry(0.05, 0.05, a);
  const bondPositions = [
    [[0,0,0], [a,0,0]], [[0,0,0], [0,a,0]], [[0,0,0], [0,0,a]],
    [[a,a,0], [0,a,0]], [[a,a,0], [a,0,0]], [[a,a,a], [0,a,a]],
    [[a,a,a], [a,0,a]], [[a,a,a], [a,a,0]], [[0,0,a], [a,0,a]],
    [[0,0,a], [0,a,a]], [[a,0,0], [a,0,a]], [[0,a,0], [0,a,a]]
  ];

  bondPositions.forEach(([start, end]) => {
    const bond = createBond(start, end, bondGeometry, bondMaterial);
    scene.add(bond);
  });
}

// Plane Visualization
export function update3DPlane(h, k, l) {
  if(planeMesh) {
    scene.remove(planeMesh);
    disposeObject(planeMesh);
  }

  const normal = new THREE.Vector3(h, k, l).normalize();
  const scale = currentMineral 
    ? Math.max(currentMineral.lattice.a, currentMineral.lattice.b, currentMineral.lattice.c) * 1.5
    : 5;

  const planeGeometry = new THREE.PlaneGeometry(scale, scale);
  const planeMaterial = new THREE.MeshPhongMaterial({
    color: getThemeColor('--plane-color'),
    transparent: true,
    opacity: 0.3,
    side: THREE.DoubleSide
  });

  planeMesh = new THREE.Mesh(planeGeometry, planeMaterial);
  planeMesh.lookAt(normal.add(planeMesh.position));
  scene.add(planeMesh);
}

// Theme Management
export function updateMaterialsForTheme() {
  scene.traverse(child => {
    if (child.isMesh) {
      if (child.material.name === 'crystalMaterial') {
        child.material.color.set(getThemeColor('--crystal-color'));
      }
      if (child.material.name === 'bondMaterial') {
        child.material.color.set(getThemeColor('--bond-color'));
      }
    }
  });
}

// Utilities
function createDynamicMaterial(type) {
  return new THREE.MeshPhongMaterial({
    name: `${type}Material`,
    color: getThemeColor(`--${type}-color`),
    ...(type === 'crystal' ? {
      metalness: 0.8,
      roughness: 0.3
    } : {
      metalness: 0.2,
      roughness: 0.7
    })
  });
}

function getThemeColor(cssVar) {
  return new THREE.Color(
    getComputedStyle(document.documentElement)
      .getPropertyValue(cssVar).trim()
  );
}

function clearScene() {
  while(scene.children.length > 0) { 
    const child = scene.children[0];
    disposeObject(child);
    scene.remove(child);
  }
}

function disposeObject(object) {
  if (object.geometry) object.geometry.dispose();
  if (object.material) {
    Object.values(object.material).forEach(prop => {
      if (prop?.dispose) prop.dispose();
    });
    object.material.dispose();
  }
}

// Animation Loop
function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}

// Window Resize Handler
window.addEventListener('resize', () => {
  const container = document.getElementById('3d-viewer');
  camera.aspect = container.clientWidth / container.clientHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(container.clientWidth, container.clientHeight);
});
